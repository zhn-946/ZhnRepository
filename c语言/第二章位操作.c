C语言学习
第二部分 位操作
1.常用位操作符
    1>位与 &(按照二进制位一个一个相与)
        注意：位与是一个&，两个&&是逻辑与
            1&0=0 1&1=1 0&0=0 0&1=0 只有1和1进行位与操作才为1，其他全为0
        区别：位与时两个操作数是按照二进制位批次相与的，逻辑与是两个操作数作为整体来相与 
        example：0xAA & 0xF0 = 0xA0;  0xAA && 0xF0 = 1;(逻辑与不为0的值都为1(true),1&&1=1)
    2>位或 |
        注意：位或是一个|，两个||是逻辑或
            1|0=1 1|1=1 0|1=1 0|0=0 只有0和0进行位或操作结果才为0，其他全为1
        区别：位或时两个操作数是按照二进制位批次相或的，逻辑或是两个操作数作为整体来相或 
    3>位取反 ~
        注意：按位取反是~，逻辑取反是！
            按位取反是将操作数的二进制位逐个按位取反(1变0，0变1)，而逻辑取反是真变假，假变真(只要不是0的任何数都是真，只有0表示假)
        任何非0的数被按逻辑取反再取反就会得到1   example:b = ~~a;
        任何非0的数被按位取反再取反就会得到它本身   example:c = !!a;
    4>位异或 ^
        2个操作数相同结果为0，不同为1
            1^1=0 0^0=0 1^0=1 0^1=1
    5>左移位<<(右移>>)
        对于无符号数，左移时右侧补0，右移时左侧补0，相当于逻辑移位
        对于有符号数，左移时右侧补0，叫算术移位，相当于逻辑移位；右移时左侧补符号位(正数补0，负数补1)，叫算术移位
        嵌入式中研究和使用的移位都是对于无符号数的移位，都是相反方向补0
2.位与、位或以及位异或的特点：
    1>位与：和1与无变化，和0与变成0
    2>位或：和1或变成1，和0或无变化
    3>位异或：和1异或会取反，和0异或无变化
3.寄存器操作要求：在设定特定位时不能影响其他位(读-改-写三部曲)
4.位与& 作用于：特定位清零   example：把0xAAAAAAAA的bit8~bit15清零――>0xAAAAAAAA & 0xFFFF00FF = 0xAAAA00AA;
  位或| 作用于：特定位置1    example：把0x12345678的bit4~bit7置1――>0x12345678 | 0x000000F0 = 0x123456F8;       
  位异或^ 作用于：特定位取反 example：把0x12345678的bit4~bit7取反――>0x12345678 ^ 0x000000F0 = 0x12345688;(7的二进制0111取反后变成1000得出8)
5.32位数据0xAA AA AA AA从左往右
    第一个AA:BIT31~BIT24
    第二个AA:BIT23~BIT16
    第三个AA:BIT15~BIT8
    第四个AA:BIT7~BIT0
6.对寄存器特定位进行置1清0或者取反时关键在于要设定一个"特定数"跟原来的寄存器内的数据进行位与位或位异或
7.解决设定麻烦特定值的方法：写代码时用位操作符号构建该特定值
    1>使用移位操作获取特定位为1的二进制数
        example1：需要一个bit3~bit7为1，其他位为0的二进制数。((0x1F)<<3)
            那么7-3+1为5个1先构建一个二进制5个1的数，先取11111为初始值0x1F，再左移3位得到特定值。
            (0x1F)<<3 = 0001 1111 <<3 相当于右侧补3个000 = 1 1111 000 = 1111 1000 = 0xF8则是bit3开始到bit7为1的二进制数
    "特定值只有一个固定长度位置置1时直接把固定长度为1的初始值移位到指定位段的开始位bitn,移动n个位置" example：指定位段bit3~bit7,则把初始值5个1(7-3+1)移bit3的3个位置。
        example2：需要一个bit3~bit7为1，同时bit23~bit25为1，其余位为0的二进制数。{((0x1F)<<3) | ((0x07)<<23)}
            那么7-3+1=5为5个1， 先取11111为初始值0x1F左移3位，再取25-23+1=3为3个1，再取111为初始值0x07左移23位，把两个值位或操作起来
            (0x07)<<23 = 0000 0111 <<23 = 111 00000000000000000000000 = 0000 0011 1000 0000 00000000 00000000 = 0x0380 0000
            同时bit3~bit7也要是1就要进行位或，或1得1 
            (0x0380 0000) | (0x0000 00F8) = (0x0380 00F8);
    "特定值同时有多个不同长度位置置1时可以分成多个初始值部分进行移位操作之后再位或|起来得到最终结果"
    2>结合位取反获取特定位为0的二进制数
        example:需要一个bit4~bit10为0，其余为1的二进制数
            方法一：也可以用左移位+位或的方式实现。(不推荐使用)
                bit4~bit10为0，意味着bit0~bit3为1，bit11~bit15为1.
                bit0~bit3为1――>3-0+1=4 == (0x0F)<<0
                bit11~bit15为1――>15-11+1=5 == (0x1F)<<11
                位或起来――>(((0x0F)<<0)|((0x1F)<<11))
            "特定位需要为0时使用移位+位或的方式可以实现，但是连续为1的特定位太多数据过大难以构造，损失优势"
            方法二：特定位(比较少)为0而其余位为1的二进制数适合使用左移位+位取反的方式实现。
                "先试图构造出二进制数的相反数，再取反得到最终结果"
                bit4~bit10为0，其余位为1的相反数是bit4~bit10为1，其余位为0
                bit4~bit10为1――>10-4+1=7 == 0111 1111 = (0x7F)<<4
                再按位取反――> (~((0x7F)<<4))
总结："多0少1直接移位和位或 多1少0先建反数再取反"
8.要置1用位或|，要清零用位与&，要取反用位异或^,取反~和左移<<右移>>用来构建特定二进制数  
    exercise1：给定一个整型数a,设置a的bit3，保证其他位不变
        a = a | (1<<3);  //a = a | 0x08;
    exercise2：给定一个整型数a,设置a的bit3~bit7，保证其他位不变
        7-3+1=5 == 000111111 = 0x1F;
        a = a | (0x1f<<3);
    exercise3：给定一个整型数a,清除a的bit15，保证其他位不变 //只有1位0多位1要构建相反数再取反
        a = a & (0<<15);/*不对*/  改正：a = a & (~(1<<15));
    exercise4：给定一个整型数a,清除a的bit15~bit23，保证其他位不变
        构建相反数 23-15+1=9 == 0001 11111111 = ~(0x01FF<<15)
        a = a & (~(0x01FF<<15));
    exercise5：给定一个整型数a,取出a的bit3~bit8    
         "先把除特定位之外的位清零 再右移到bit0位开始 得到最终取出的结果"
         //错误：bit0~bit2以及bit9~bit15 (~(0x07<<0)) & (~(0x7f)<<9)
         //复杂：{(~(0x07<<0)) & (~(0x7f)<<9)}>>3
         特定位之外清零 8-3+1=6――> a = a & (0x3f<<3);
         再右移到bit0开始 a = a>>3
    exercise6：用C语言给一个寄存器的bit7~bit17赋值937(其余位不受影响)
        "直接赋值前指定位数据未知，先清空指定位再赋值"
        指定位清零 17-7+1=11――> a = a & (~(0x7ff<<7))
        bit7~bit17赋值 a = a | (937<<7);
    exercise7：用C语言给一个寄存器的bit7~bit17中的值加17(其余位不受影响)
        "在原有的值上加值先读取原来的值 给这个值加值 再把原来值指定位清零再赋值 中间需借助局部变量"
        取bit7~bit17原有值 把除指定位之外清零再右移到bit0  17-7+1=11――> b = a & (0x7ff<<7); b = b>>7;
        给局部变量加值 b = b + 17;
        把原来值指定位清空 a = a & (~(0x7ff<<7));
        局部变量赋值给原来值指定位 a = a |(b<<7);
        
    exercise8：用C语言给一个寄存器的bit7~bit17赋值937，同时给bit21~bit25赋值17   
        "多个指定位段清零时结合起来用位或"    
        指定位清零 17-7+1=11 25-21+1=5――> a = a & (~((0x7ff<<7)|(0x1f<<21 )));//不一定错误：a = a & (~(0x7ff<<7)) & (~(0x1f<<21)));
        指定位赋值 a = a | (937<<7) | (17<<21);
        "宏定义定义数值可以表示数值什么意思"
            example：
            #define VALUE1 937
            #define VALUE2 17
            a = a | (VALUE1<<7) | (VALUE2<<21);  
9.写宏定义时需要在后边宏体数据位(是公式的情况下)上添加括号  #define SET_BIT_N(x,n)  "(data.......)"
10.用宏定义把某个bitn置1：#define SET_BIT_N(x,n)  (x|(1U<<n))     "加U表示1是无符号的1"
    example:{unsigned int a,b = 0; b = SET_BIT_N(a,3); printf("b = 0x%x.\n",b); return 0;}
11.用宏定义把某个bitn清0：#define CLEAR_BIT_N(x,n)  (x & (~(1U<<n)))
12.用宏定义把连续一段bitn到bitm置1：
    需要一个m-n+1个1的二进制数―――>先用32个1  ~0U (0U就是32个0取反就是32个1)
                                在右移32-(m-n+1)位得到m-n+1个1  (~0U)>>(32-(m-n+1))
    #define SET_BIT_N_M(x,n,m)  (x|((~0U)>>(32-(m-n+1))<<n))
13.用宏定义截取变量x的bitn到bitm部分连续位：
    //特定位之外清零  (x &(((~0U)>>(32-(m-n+1)))<<n)) >>n
    #define  GET_BIT_N_M(x,n,m)   ((x&~(~(0U)<<(m-n+1))<<n) >>n)
    分解：(x&~(~(0U)<<(m-n+1))<<n)――――>x  &  ~(~(0U)<<(m-n+1))<<n――――>~(~(0U)<<(m-n+1))  <<n (取反优先级高于左移)
            ――――>~(~(0U)<<(m-n+1)) 
                ~(0U)32个1左移m-n+1位再取反――――> m-n+1个1的二进制数
                <<n――――>指定位全1
                &x――――>除指定位之外清零
                <<n――――>取出特定位段的值
  