C语言学习
第一部分 内存
1.程序运行的目的2个：结果(返回值)、过程
    函数的形参、以及函数内的临时数据(局部变量)就是待加工的数据，函数本体就是代码，函数的返回值就是结果，函数体的执行过程就是过程。
2.Dram动态内存和Sram静态内存
    1>内部结构不同(dram依靠电容存储，sram依靠触发器存储数据)，
    2>寻址方式不同(dram分两次发送行地址线和列地址线，可以复用，sram同时发送，存取速度很快)
内存用来存储可变数据，数据表现为全局和局部等。常量存储在flash中，在代码段中。
3.有操作系统时管理内存
    1>操作系统掌握所有硬件内存，把内存分成一块一块4kb页面，以页面为单位来管理，页面内以字节为单位管理，操作系提供内存管理接口，开发人员只需要API管理，例如malloc和free。
    2>无操作系统时管理内存，程序直接操作内存，需要自己计算内存使用和安排。
4.当我们程序对性能非常要求时(操作系统内核)会用c/c++，当我们对开发速度非常要求时就会用Java/c#
5.内存逻辑上是一个格子，每个格子有一个编号是内存地址。内存地址和格子空间一一对应且永久绑定，每个格子的大小固定为1个字节，这是内存的编址方法。Cpu只关心逻辑只关心地址编号，不关心格子空间在哪。内存单元有2个概念：地址和空间。
6.内存编址是以字节为单位的，什么意思呢就是随便给一个数字，一个数字就是一个内存地址，地址对应的空间大小固定就是1个字节（8bit）也就是每个格子的大小。
7.内存与数据类型的关系：
    C语言的基本数据类型char字节  short短整型（半个int）  int整型  long长整型  float浮点  double双精度浮点
    int 整数类型 
        int和cpu本身数据位宽一样  32位cpu int就是32位（4个字节）数据类型定义变量，变量存储运算在内存。数据类型必须和内存大小相匹配，访问效率高32位硬件就适合定义32位int类型变量。
            Bool类型变量实际上只需要一个bit ，但是32位系统下都是用int实现，浪费31位内存但是好处时效率高节省时间。（bool b1；）
8.内存访问； 
    对齐访问（0123），非对齐访问（1234，2345，3456类似）是硬件问题 0123是32位本身逻辑就相关性高。
        对齐访问配合硬件，效率高。非对齐访问不匹配硬件本身，效率不高。
9.C语言封装内存地址  用变量名来访问内存
    int a；表示 a和一个格子
    A = 5 表示格子放入5
    A +=4表示取格子中的值加上4再放入格子
数据类型本质 含义 表示一个内存格子的长度和解析方法
    内存单元格子的编址地址单位是字节。
        强制类型转换   类型转换跟数据本质无关，转换的是类型
        （int *）0；   0中存的一个int类型指针
        （float *）0；  0中存的一个float类型指针 指针指向float类型的数  
        （short）0； 0中存的是一个short类型的数
        （char）0；  0中存的是一个char类型的数  
    1>数据类型决定长度的含义就是本来一个内存地址（也就是变量名）仅代表一个字节长度大小，但是可以给他一个数据类型，让他从这个地址开始连续n个字节的格子空间。
        example:例如一个地址（0x30000000）本代表1个字节长度，但是给他一个int类型，有了长度4，那0x30000000代表从0x30000000开始的连续的(0x30000000+0x30000001+0x30000002+0x30000003)4个字节的内存格子。
    2>数据类型决定解析方法的含义就是给内存地址不同的数据类型指定这个单元格子中二进制数的解析方法。
        example:例如给0x30000000这个内存地址一个int类型，写成(int)0x30000000，表示连续4个格子(0x30000000+0x30000001+0x30000002+0x30000003)代表一个int型解析方式的数据。给0x30000000这个内存地址一个float类型，写成(int)0x30000000，表示连续4个格子(0x30000000+0x30000001+0x30000002+0x30000003)代表一个float型解析方式的数据。
        int类型是整数，float类型是浮点数，32位二进制的解析方法不同。地址还是原来的地址，存的内容也是原来的32位二进制，4个格子也是原来的4个格子，只是数据的解析方式不同。
10.函数名的实质就是一段代码的首地址！！！！  也就是一个内存地址罢了
11.关于类型（不管是普通变量还是指针）只是对后面的数字或者符号（数字或者符号代表的都是内存地址，编译器知道是多少，我不知道）代表的内存只有长度规定和解析方法不同。
    example:int a和int *p没有任何区别，a和p都代表一个内存地址，只是这个内存地址的长度和解析方法不同。a是int型是长度4个字节的int解析方法的数据，p是int *类型是长度是4个字节的int*指针解析方法的数据
    example:给p分配的内存地址是0x20000000，那么int *p代表0x20000000开始的连续的4个字节中存储了1个地址，这个地址所代表的内存单元中存放1个int类型的数）。
12.普通变量，指针变量，数组变量管理内存本质上都是一样的，都是对内存地址的解析，只是长度和解析方式的不同而已。
    int a; 	//分配4字节长度给a，并把首地址和符号a绑定起来
    int b[10]; 	//分配40个字节长度给b，并把首元素首地址和b绑定
13.数组的优势和缺陷 
    数组优势：使用简单，访问用下标，可以随机访问;
    数组缺陷：1>数组中元素类型必须相同 2>数组大小必须定义时给出，一旦确定不能在改。
14.要保存数据的数据类型相同时结构体和数组的作用相同,且数组比结构体更简单;当数据内容数据类型不同时,必须用结构体
15.结构体内嵌指针实现面向对象
    C语言是面向过程的,但是C语言写出的linux系统是面向对象的;用c++/java等面向对象的语言来实现面向对象简单一点,用C语言实现比较麻烦.
struct 函数指针
{
    int a;/* 普通变量 */
    void (*pFunc)(void);/*函数指针,指向void func (void)这类的函数*/
};
    example1:
    int Add(int a,int b)
    {
        return a+b;
    }
    int (*p)(int,int) = &Add;
    int result = (*p)(3,5) = p(3,5) = Add(3,5);
    编译器认为函数名就是函数指针....这给我真无语了
    函数名做右值时,取地址符号&加或不加都是一样的,但是数组名做右值时加或不加&是不一样的.

    example2:
    void func(int a,int b)
    {
        int c;
        c = a+b;        
    }
    struct 函数指针 p;
    p.pFunc = &func;    /*等价于p.pFunc = func*/ 函数名是等于&函数名的
    

16.stack 栈是一种数据结构,来保存一种局部变量;栈是管理内存的一种方式,
    栈顶指针top和栈底指针bottom;bottom不动一直指向栈的开始,top可以移动
    栈的特性：先进后出FILO;先进去后出来 ，一个口，入口即出口
    队列的特性：先进先出FIFO；先进去先出来，两个口
17.C语言中局部变量是用栈实现的，局部变量在使用完该函数后就消失。但注意：定义局部变量时如果未初始化，则值是随机的。
    int a = 15;/*定义+初始化赋值*/ 等价于 int a;/*局部变量定义*/  a = 15; //赋值
18.static静态变量只会在第一次使用时被执行一次，之后不会再次执行。静态变量初始值为0
    example： static uint32_t timer_ms; //静态变量作用域和生命周期不同于其他普通变量，值在程序运行期间一直存在
19.栈有大小，内存不太灵活，大小不好设置，太小会溢出；太大会浪费内存。定义局部变量不能太多不能太大。
   使用递归来解决问题时一定要注意递归收敛
20.heap 堆是另外一种内存管理方式。随时申请，随时释放，随意大小。在需要内存容量比较大，反复使用和释放时适合放在堆。（malloc和free）
    example：链表，二叉树等数据结构的实现都来使用堆内存。
21.堆管理内存的特点：1>容量不限(常规使用的需求容量都能够满足),2>申请及释放都需要软件明确申请malloc和释放free。
22.内存泄漏：软件申请内存未释放，造成内存丢失，软件再用申请新的内存。
23.内存申请：void *malloc(size_t size); //传一个长度size
            void *calloc(size_t nmemb,size_t size);//传一个nmemb单元，每个单元size长度
                example： p1 = (int *)malloc(sizeof(int)*10);
            void *realloc(void *ptr,size_t size);
   内存释放：void free(void *ptr);
24.链表使用：定义结构体实现链表，节点插入(前插，后插)，节点删除，节点查找，节点遍历等
25.